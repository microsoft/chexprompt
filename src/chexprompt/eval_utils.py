import logging
from typing import Dict, List, Tuple

ERROR_TYPE_MAP = {
    "A": "false_positive_finding",
    "B": "omission_finding",
    "C": "incorrect_location",
    "D": "incorrect_severity",
    "E": "false_positive_comparison",
    "F": "omission_comparison",
}


def format_full_prompt(system_prompt: str, user_prompt: str) -> List[Dict[str, str]]:
    """Returns a list of dictionaries with the system and user prompts."""

    return [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt},
    ]


def parse_completion_tuples_to_dict(completion_text: str) -> Dict[str, int] | None:
    """Parses a completion text  to a dictionary.

    Args:
    - completion_text: str, the completion text in the form ((A, 0), (B, 1), (C, 0), ...)

    Returns:
    - completion_dict: Dict[str, int], the parsed completion dictionary

    """
    completion_dict = {}

    completion_text = (
        completion_text.replace("),", "::")
        .replace("(", "")
        .replace(")", "")
        .replace("[", "")
        .replace("]", "")
    )
    completion_text = completion_text.split("::")

    try:
        for pair in completion_text:
            pair = pair.strip().split(",")
            error_key = (
                ERROR_TYPE_MAP[pair[0].strip()]
                if pair[0].strip() in ERROR_TYPE_MAP
                else pair[0].strip()
            )
            completion_dict[error_key] = int(pair[1].strip())

    except Exception as e:
        logging.error(f"Error parsing completion text: {e}")
        return

    return completion_dict


def parse_rating_text(rating_text: str) -> Tuple[Dict[str, int], Dict[str, int]]:
    """Parses a rating text to dictionaries.

    Args:
    - rating_text: str, the free-text ratings generated by CheXprompt

    Returns:
    - clinically_significant: Dict[str, int], the parsed clinically significant errors by type
    - clinically_insignificant: Dict[str, int], the parsed clinically insignificant errors by type
    """
    clin_signif_errors = None
    clin_insignif_errors = None

    if "Number of clinically significant errors by type:" not in rating_text:
        return clin_signif_errors, clin_insignif_errors

    def _check_remove_explanations(text: str) -> str:
        """Remove explanation of errors from the rating text."""
        for prefix in ["Explanation", "Explanation of errors:"]:
            if prefix in text:
                return text.split(prefix)[0]
        return text

    def _get_significant_insignificant_tuple_lists(rating_text: str) -> Tuple[str, str]:
        """Get the significant and insignificant errors as strings."""
        insignificant = rating_text.split(
            "\nNumber of clinically insignificant errors by type:"
        )[-1].strip()

        significant = (
            rating_text.split("\nNumber of clinically insignificant errors by type:")[0]
            .split("Number of clinically significant errors by type: ")[-1]
            .strip()
        )

        return significant, insignificant

    rating_text = _check_remove_explanations(rating_text)

    significant_seq, insignificant_seq = _get_significant_insignificant_tuple_lists(
        rating_text
    )

    clin_signif_errors = parse_completion_tuples_to_dict(significant_seq)
    clin_insignif_errors = parse_completion_tuples_to_dict(insignificant_seq)

    return clin_signif_errors, clin_insignif_errors


def is_valid_rating_text(rating_text: str) -> bool:
    """Checks if the rating text is valid.

    Args:
    - rating_text: str, the free-text ratings generated by CheXprompt

    Returns:
    - valid: bool, True if the rating text is valid, False otherwise
    """
    if rating_text.strip() == "":
        return False
    elif "Number of clinically significant errors by type:" not in rating_text:
        return False
    elif "Number of clinically insignificant errors by type:" not in rating_text:
        return False

    return True


def extract_valid_rating_text(completion_dict: Dict[str, str]) -> str:
    """Extracts the rating text from the completion text.

    Args:
    - completion_text: Dict[str, str], the completion text from OpenAI API

    Returns:
    - rating_text: str, the extracted rating text in free-text form
    """
    if len(completion_dict) == 0:
        return None

    completion_text = completion_dict["choices"][0]["message"]["content"]

    if is_valid_rating_text(completion_text):
        return completion_text

    return


def extract_rating_dicts(
    completion: Dict[str, str]
) -> Tuple[Dict[str, int], Dict[str, int]]:
    """Extracts the rating dictionaries from the completion text.

    Args:
    - completion: Dict[str, str], the completion text from OpenAI API

    Returns:
    - clinically_significant: Dict[str, int], the parsed clinically significant errors by type
    - clinically_insignificant: Dict[str, int], the parsed clinically insignificant errors by type
    """
    rating_text = extract_valid_rating_text(completion)

    if rating_text is None:
        return None, None

    return parse_rating_text(rating_text)
